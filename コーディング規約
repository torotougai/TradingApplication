-----

# FastAPI 総合コーディング規約 (Python 3.12) 🚀

この規約は、FastAPIプロジェクトのコードの品質、可読性、保守性、セキュリティ、パフォーマンスを総合的に高めることを目的としています。初心者から経験者までが共通のベストプラクティスに基づき、円滑にチーム開発を進めるための詳細なルールを定めます。

## 目次

1.  [はじめに：なぜ規約が必要か？](https://www.google.com/search?q=%231-%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB%E3%81%AA%E3%81%9C%E8%A6%8F%E7%B4%84%E3%81%8C%E5%BF%85%E8%A6%81%E3%81%8B)
2.  [基本原則とツール](https://www.google.com/search?q=%232-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%89%87%E3%81%A8%E3%83%84%E3%83%BC%E3%83%AB)
3.  [命名とプロジェクト構造](https://www.google.com/search?q=%233-%E5%91%BD%E5%90%8D%E3%81%A8%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%A7%8B%E9%80%A0)
4.  [API設計とドキュメンテーション](https://www.google.com/search?q=%234-api%E8%A8%AD%E8%A8%88%E3%81%A8%E3%83%89%E3%82%AD%E3%83%A5%E3%83%A1%E3%83%B3%E3%83%86%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3)
5.  [FastAPI 実装規約](https://www.google.com/search?q=%235-fastapi-%E5%AE%9F%E8%A3%85%E8%A6%8F%E7%B4%84)
6.  [非同期処理](https://www.google.com/search?q=%236-%E9%9D%9E%E5%90%8C%E6%9C%9F%E5%87%A6%E7%90%86)
7.  [エラーハンドリングとロギング](https://www.google.com/search?q=%237-%E3%82%A8%E3%83%A9%E3%83%BC%E3%83%8F%E3%83%B3%E3%83%89%E3%83%AA%E3%83%B3%E3%82%B0%E3%81%A8%E3%83%AD%E3%82%AE%E3%83%B3%E3%82%B0)
8.  [データベース](https://www.google.com/search?q=%238-%E3%83%87%E3%83%BC%E3%82%BF%E3%83%99%E3%83%BC%E3%82%B9)
9.  [セキュリティ](https://www.google.com/search?q=%239-%E3%82%BB%E3%82%AD%E3%83%A5%E3%83%AA%E3%83%86%E3%82%A3)
10. [テスト](https://www.google.com/search?q=%2310-%E3%83%86%E3%82%B9%E3%83%88)
11. [パフォーマンス](https://www.google.com/search?q=%2311-%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9)
12. [開発ワークフロー](https://www.google.com/search?q=%2312-%E9%96%8B%E7%99%BA%E3%83%AF%E3%83%BC%E3%82%AF%E3%83%95%E3%83%AD%E3%83%BC)

-----

### 1\. はじめに：なぜ規約が必要か？

一貫したコーディングスタイルは、以下のようなメリットをもたらします。

  - **可読性の向上**: 誰が書いても同じようなスタイルのコードになり、他の人が読みやすく、理解しやすくなります。
  - **品質の担保**: バグが入り込みにくい、堅牢なコードを書くための指針となります。
  - **開発効率の向上**: コーディングの際に迷うことが減り、本質的なロジックの実装に集中できます。
  - **メンテナンスの容易化**: 将来の機能追加や修正がスムーズに行えるようになります。
  - **セキュリティの強化**: 脆弱性を生み出しやすいパターンを避け、安全なアプリケーションを構築します。

-----

### 2\. 基本原則とツール

#### 2.1. コーディングスタイル

**原則: [PEP 8](https://pep8-ja.readthedocs.io/ja/latest/) に準拠します。**

#### 2.2. フォーマッターとリンター

コードの品質とスタイルを自動で維持するため、以下のツールを必須とします。

  - **フォーマッター**: **`black`** または **`ruff format`**
      - 議論の余地なくコードの見た目を統一します。
  - **リンター**: **`Ruff`**
      - PEP 8違反、論理エラー、非効率なコードなどを高速に検出・修正します。

#### 2.3. 静的型チェッカー

  - **`mypy`** を導入し、型ヒントの整合性をCI/CDプロセスで検証します。これにより、実行時エラーを未然に防ぎます。

<!-- end list -->

```toml
# pyproject.toml の設定例
[tool.black]
line-length = 88

[tool.ruff]
line-length = 88
select = ["E", "F", "W", "I", "UP", "C4", "B", "A", "RUF"] # チェックするルールを拡張
ignore = []

[tool.ruff.lint.isort]
known-first-party = ["app"]

[tool.mypy]
python_version = "3.12"
warn_return_any = true
ignore_missing_imports = true
```

-----

### 3\. 命名とプロジェクト構造

#### 3.1. 命名規則

分かりやすい名前は、良いコードの第一歩です。

| 対象 | 命名規則 | 良い例 ✅ | 悪い例 ❌ |
| :--- | :--- | :--- | :--- |
| **変数・関数** | スネークケース (`snake_case`) | `user_name`, `get_active_users()` | `userName`, `UserGet()` |
| **クラス** | パスカルケース (`PascalCase`) | `User`, `ItemSchema` | `user`, `item_schema` |
| **定数** | アッパーケース (`UPPER_CASE`) | `MAX_CONNECTIONS = 10` | `max_connections = 10` |
| **ファイル・モジュール** | スネークケース (`snake_case.py`) | `user_router.py`, `database.py` | `userRouter.py` |

#### 3.2. プロジェクト構造

見通しが良く、スケールしやすいディレクトリ構造を採用します。

```bash
your_project/
├── app/                      # アプリケーションのメインコード
│   ├── __init__.py
│   ├── main.py               # FastAPIアプリのインスタンス化、ミドルウェア、ルーター登録
│   ├── config.py             # pydantic-settingsによる設定管理
│   ├── routers/              # エンドポイント定義
│   │   └── users.py
│   ├── schemas/              # Pydanticモデル
│   │   └── user_schema.py
│   ├── crud/                 # DBのCRUD操作レイヤー
│   │   └── user_crud.py
│   ├── models/               # ORMモデル (SQLAlchemy)
│   │   └── user_model.py
│   ├── services/             # 複数のCRUDを組み合わせるなど、より複雑なビジネスロジック
│   │   └── user_service.py
│   ├── dependencies.py       # 共通の依存性注入 (DBセッション、認証など)
│   └── core/                 # プロジェクト全体で利用するコア機能 (ロガー設定など)
│
├── tests/                    # テストコード
│   └── ...
├── alembic/                  # DBマイグレーションファイル (Alembic)
├── .env                      # 環境変数 (Gitに含めない)
├── alembic.ini               # Alembic設定ファイル
├── pyproject.toml            # プロジェクトとツールの設定ファイル
└── README.md                 # プロジェクトの説明書
```

-----

### 4\. API設計とドキュメンテーション

#### 4.1. RESTful設計原則

  - **URL**: リソース（資源）を表現する名詞の複数形を使用します。（例: `/users`, `/items`）
  - **HTTPメソッド**: 操作に応じて適切なメソッドを使い分けます。
      - `GET`: リソースの取得
      - `POST`: リソースの新規作成
      - `PUT`: リソースの完全な置換・更新
      - `PATCH`: リソースの部分的な更新
      - `DELETE`: リソースの削除

#### 4.2. APIバージョニング

将来的な仕様変更に備え、URLにバージョンを含めます。

  - 例: `@router.get("/api/v1/users/{user_id}")`

#### 4.3. ステータスコードの使い分け

レスポンスの意味を明確にするため、適切なHTTPステータスコードを返します。

  - `200 OK`: 成功 (GET, PUT, PATCH)
  - `201 Created`: 作成成功 (POST)
  - `204 No Content`: 成功したが返すコンテンツがない (DELETE)
  - `400 Bad Request`: リクエストの形式が不正 (バリデーションエラー)
  - `401 Unauthorized`: 認証が必要（トークンがない、など）
  - `403 Forbidden`: 認証済みだが権限がない
  - `404 Not Found`: リソースが存在しない

#### 4.4. ドキュメンテーション

  - **Docstring**: 各パスオペレーション関数には、その機能、パラメータ、返り値について記述します。これが自動生成されるAPIドキュメント (`/docs`) の説明になります。
  - **`README.md`**: プロジェクトの概要、セットアップ手順、環境変数の説明、実行方法、テスト方法を必ず記述します。

-----

### 5\. FastAPI 実装規約

#### 5.1. パスオペレーション (エンドポイント)

  - **具体的な関数名**: `get_user_by_id`, `create_item_for_user` など、処理内容が明確にわかる名前を付けます。
  - **`response_model` の必須化**: レスポンスに含めるデータをスキーマで厳密に定義し、意図しない情報の漏洩を防ぎます。
  - **`tags` の活用**: APIドキュメントを機能ごとにグループ化するために、`APIRouter` や各エンドポイントで `tags` を指定します。

#### 5.2. Pydanticモデル (スキーマ)

  - **役割に応じたクラス分割**: `UserCreate` (作成), `UserUpdate` (更新), `UserInDB` (DB), `User` (レスポンス) のように、用途に応じてモデルを細かく定義します。
  - **`Field` の活用**: バリデーションルール (`min_length`, `gt`など）、デフォルト値、ドキュメント用の説明 (`description`, `examples`) を明記します。

#### 5.3. 依存性注入 (Dependencies)

  - DBセッション管理、認証ロジック、設定オブジェクトの取得など、横断的に利用する機能は `Depends` を使って積極的に切り出します。これにより、再利用性とテスト容易性が大幅に向上します。

#### 5.4. 型ヒント (Type Hinting)

  - **完全な型付け**: すべての関数・メソッドの引数と返り値に型ヒントを付けます。
  - **モダンな構文**: `list[str]`, `dict[str, int]`, `str | None` といったPython 3.10以降の構文を使用します。

-----

### 6\. 非同期処理

#### 6.1. `async/await` の基本

  - ネットワークI/OやDBアクセスなど、待ち時間が発生する処理は **必ず** `async def` で定義し、`await` を使って呼び出します。

#### 6.2. I/Oバウンド vs CPUバウンド

  - **I/Oバウンド処理** (DBアクセス、API呼び出しなど): `async/await` を使います。
  - **CPUバウンド処理** (重い計算、画像処理など): `async def` の中で直接実行してはいけません。イベントループをブロックしてしまいます。`fastapi.concurrency.run_in_threadpool` を使うか、別プロセスで処理します。

<!-- end list -->

```python
from fastapi.concurrency import run_in_threadpool

def cpu_bound_task(data: str) -> str:
    # 時間のかかる同期的処理
    return data.upper()

@app.post("/process")
async def process_data(data: str):
    # 非同期関数内で、同期的で重い処理を安全に呼び出す
    result = await run_in_threadpool(cpu_bound_task, data=data)
    return {"result": result}
```

#### 6.3. バックグラウンドタスク (`BackgroundTasks`)

  - リクエストのレスポンスを返した後に実行したい処理（例: メール送信、ログの書き込み）には `BackgroundTasks` を利用します。ただし、タスクの実行は保証されないため、重要度の高い処理にはCeleryなどの専用タスクキューを検討します。

-----

### 7\. エラーハンドリングとロギング

#### 7.1. エラーハンドリング

  - **`HTTPException`**: クライアント起因のエラー（4xx系）に使用します。
  - **カスタム例外ハンドラ**: アプリケーション固有のビジネスロジックエラーを補足し、特定のエラーレスポンスを返すために `@app.exception_handler` を使用します。これにより、ロジック層がHTTPの詳細に依存しなくなります。

#### 7.2. ロギング

  - **構造化ロギング**: JSON形式などでログを出力し、後から検索・集計しやすくします。
  - **リクエストID**: ミドルウェアを使って各リクエストに一意のIDを付与し、ログに含めることで、リクエストの処理フローを追跡しやすくします。
  - **ログレベルの使い分け**:
      - `INFO`: 通常の動作記録（リクエスト受信、処理完了など）
      - `WARNING`: 即時対応は不要だが、注意すべき事象（非推奨APIの使用など）
      - `ERROR`: 処理の続行が不可能なエラー（DB接続断、予期せぬ例外など）
  - **機密情報をログに出力しない**: パスワード、APIキー、個人情報などをログに含めないよう注意します。

-----

### 8\. データベース

#### 8.1. ORM (SQLAlchemy)

  - モデル定義は `models/`、CRUD操作は `crud/` に分離し、責務を明確にします。
  - アプリケーションロジック（`routers/`, `services/`）から直接ORMモデルを操作するのではなく、`crud/` レイヤーを介してアクセスします。

#### 8.2. セッション管理

  - DBセッションは `dependencies.py` で定義した `Depends` 関数を通じて取得・クローズします。これにより、コネクションリークを防ぎます。

#### 8.3. マイグレーション

  - **Alembic** を使用してデータベーススキーマの変更を管理します。変更はすべてマイグレーションスクリプトとしてバージョン管理し、手動でのDB変更は禁止します。

-----

### 9\. セキュリティ

#### 9.1. 認証と認可

  - **`fastapi.security`** (`OAuth2PasswordBearer`など) を活用して、堅牢な認証フローを実装します。トークン（JWTなど）の検証は `Depends` に切り出します。
  - 認可（ロールベースのアクセス制御など）は、認証済みユーザー情報を使って専用の依存関係を作成します。

#### 9.2. CORS設定

  - `CORSMiddleware` を使って、APIへのアクセスを許可するオリジンを明示的に指定します。本番環境で `allow_origins=["*"]` を使用することは避けてください。

#### 9.3. 機密情報の管理

  - **`pydantic-settings`** を使って、環境変数や `.env` ファイルから設定値を読み込みます。
  - APIキー、DBパスワードなどの機密情報は、コードにハードコーディングせず、必ず環境変数やSecrets Managerなどの外部サービスから注入します。

#### 9.4. 入力値の検証

  - Pydanticによる型とバリデーションは強力ですが、SQLインジェクションなどの脆弱性はDB操作のレイヤーで別途注意が必要です。ORMのプレースホルダーを正しく使用し、生のSQLクエリの組み立ては避けます。

-----

### 10\. テスト

#### 10.1. テストの基本

  - **`pytest`** と FastAPI の `TestClient` を使用します。
  - テスト用のデータベースを使い、本番や開発DBとは分離します。

#### 10.2. テスト対象

  - **単体テスト**: `crud`, `services` レイヤーのビジネスロジック。
  - **結合テスト**: `TestClient` を使ったエンドポイントのテスト。
      - 正常系のテスト（2xxステータス）
      - 異常系のテスト（バリデーションエラー、認証エラー、リソース不存在など 4xxステータス）
      - エッジケースのテスト

-----

### 11\. パフォーマンス

#### 11.1. N+1問題の回避

  - SQLAlchemyでリレーションシップを持つデータを取得する際は、`selectinload` や `joinedload` を使って、意図しないループでのクエリ発行（N+1問題）を防ぎます。

#### 11.2. キャッシング

  - 頻繁にアクセスされ、内容があまり変わらないエンドポイントには、Redisなどを使ったキャッシュ戦略を検討します。`fastapi-cache2` のようなライブラリの活用も有効です。

-----

### 12\. 開発ワークフロー

#### 12.1. バージョン管理 (Git)

  - **ブランチ戦略**: `main` (本番), `develop` (開発), `feat/xxx` (機能開発) のようなGit-flowやGitHub Flowに準じたブランチ戦略を採用します。
  - **コミットメッセージ**: [Conventional Commits](https://www.conventionalcommits.org/ja/v1.0.0/) に従い、`feat:`, `fix:`, `docs:` などのプレフィックスを付けてコミットの意図を明確にします。
  - **Pull Request**: レビュー依頼時には、変更の概要、理由、テスト方法などをテンプレートに沿って記述します。

#### 12.2. 依存関係の管理

  - **`poetry`** または **`pdm`** を使用して、依存ライブラリのバージョンを `pyproject.toml` とロックファイルで厳密に管理します。これにより、全開発者の環境を一致させます。
  - 定期的に `poetry update` などでライブラリを更新し、セキュリティ脆弱性に対応します。

#### 12.3. CI/CD

  - Pull Requestやマージをトリガーに、CI（継続的インテグレーション）パイプラインで以下の処理を自動実行します。
    1.  リンター (`ruff`)
    2.  静的型チェック (`mypy`)
    3.  テスト (`pytest`)
  - main/developブランチへのマージ後、CD（継続的デプロイ）によってステージング/本番環境へ自動デプロイする仕組みを構築します。
